# this is 03.hexlet.git.txt
# use 4-space tab to read
# source 1: https://ru.hexlet.io/courses/intro_to_git as the initial framework
# source 2: https://learngitbranching.js.org/?locale=ru_RU&demo= - good exercise equipment about branches
# source 3: https://www.youtube.com/watch?v=O00FTZDxD0o&ab_channel=BogdanStashchuk - good about base of git

				hexlet.git.01	Introduction
				hexlet.git.02	Installation and thesettings
SSH (Safety shell) - it`s not a shell - it`s a safe transport protocol
Make ssh-keys couple:
	open terminal
		ssh-keygen -t ed25519  -C "your_email@example.com"	# makes a couple ssh-keys
		eval "$(ssh-agent -s)"								# runs ssh agent to watch the keys
		ssh-add ~/.ssh/id_ed25519 							# adds new ssh key to agent
		cat ~/.ssh/id_ed25519.pub							# shows open key (we may take it here)
	https://github.com/settings/keys						# open site
		press 'New SSH key' button
		insert copyed key and come up new key-name

				hexlet.git.03	Work process
git init					# run in working directory of project
							# make a repository (in .git directory)
							# contains all necessary to git
git status					# show repository status (shows all commited files, only commited files)
git add myFile				# prepares myFile to commit (adds myFile to index, marks myFile like staged)
git commit -m 'comment'		# sand all prepared files to repository as one whole
							# -m - cover message of current commit
							# Every commit must be atomicity - implements only one task

GIT-sheet: https://about.gitlab.com/images/press/git-cheat-sheet.pdf
Соглашение о коммитах: https://www.conventionalcommits.org/ru/v1.0.0/
Что такое Git... https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-Git%3F

				hexlet.git.04	Integration to Github
		Manualy make an empty repository hexlet-git on github.com
git remote					# show remote repository to current local one
git remote -v				# show settings of remote to local repository binding
git remote add origin <url>	# bind current local repository to remote one
							# origin - new local name of remote repository
git branch -M main			# rename current local branch to main
git push -u origin main		# bind local current branch to remote main in origin and make push
...finish!!!  Update our new repository on github.com

		Make a copy of repository from github.com:
rm -r hexlet-git			# remove local repository
git clone <url>				# clone origin to local directory
git pull --rebase			# synchronise local repo from server
git log						# show git operations log

Bitbucket - an alternative of github
GitLab - an alternative of github (also for own servers)

Task: copy git from repos/git-user to repos/git-user, change two files and push them to main git
git clone repos/git-user code-user
cd code-user/
echo 'I like to change files' >> hexlet.txt
echo '<h1>С помощью гит можно писать книги</h1>' > index.html
git add .		# 
git config --global user.email "you@example.com"	# set e-mail for git
git config --global user.name "Your Name"			# set your name fog git
git config --list									# show git settings
git commit -m 'fix hexlet.txt and index.html'
git push

				hexlet.git.05	Working directory
git restore myFile					# restores myFile to working directory from git,
									# cansels non commited changes in myFile
There are two ways to remove file from git:
1.	rm myFile						# removes file from working directory
	git add myFile					# marks myFile to tracking and fixes changes to commit

2.	git rm myFile					# works like rm myFile + git add myFile (but not commit yet)

-.	git commit -m 'remove myFile'	# commits all staged changes to current local git
	git push						# pushes all commits to server git

				hexlet.git.06	Analysis of changes
git diff			# (--cached by default) shows all file changes in work directory compared to git
					# changes are demonstrates in pager with it's own controlling:
					# f (forward), b, u (back, up), q (quit), /text (looking text)... n (next)... N (previous)
git diff --staged	# shows changes in files prepared to committing

				hexlet.git.07	Analysis of commit history
git log				# shows commit history (from commit in current HEAD to the root commit)
git log -p			# shows commit history with diffs
git show hashNumber	# shows the diff for hashNumber commit
					# it`s enought to specify the first 7 characters of hashNumber
git blame myFile	# shows the entire myFile with each line history
git grep myWord		# shows every line in every file containing myWord
git grep -i myWord						# the same, but not case sensitive
git grep myWord hashNumber				# the same, but only in hashNumber commite
git grep myWord $(git rev-list --all)	# shows full commit list with hashNumbers

				hexlet.git.08	Canseling in working directory (before commit)
git clean 					# remove all untracked not ignored files
							# -f - force, second -f may be used while cleaning after copying from another git
							# -n - not delete - only show what would be deleted
							# -d – remove also directory
							# -x - remove also ignored files
							# -i - interactive cleaning
git restore myFile 			# restores myFile to working directory ((is staged) ? from staged : from git)
git restore --staged myFile # restores myFile from last commit to staged and cancels indexing of myFile

				hexlet.git.09	Canseling after commits
git revert <what>			# add to HEAD a new commit canceling changes of the <what> commit
git reset  <where>			# (applicapable only for non pushed commit)
							# move HEAD to <where>
							# and send changes of <where> commit to working directory
git reset --mixed <where>	# --mixed - by default
git reset --hard <where>	# --hard - set HEAD to <where> and delete all released commits

				hexlet.git.10	Changing of last commit
git commit --amend			# (applicapable only for non pushed commit) 
							# add new staged changes to already existed commit or to change comment
							# (under the hood) makes revert, then repeats last commit with the same comment
git commit --amend --no-edit# add new staged changes without opening comments

				hexlet.git.11	Index
git commit <files>			# commit already tracked <files>
git commit -a				# commit all changed tracked files
git add .					# marks to track and stages all files in working directory
git add -i					# (--interactive) flexible staging
git add -p					# (--patch) stage a part of changes in file
git reset -p				# (--patch) cancel a part of previous commit
git stash save -p			# makes a stage stash in files changes

				hexlet.git.12	Moving through History
git log --oneline			# show commits with hashes and comments
git shortlog				# show commits with authors and comments
git checkout <hash>			# switch HEAD to <hash> commit
git checkout main			# back control into main branch
git switch -				# back control into main branch
git branch					# show all branches
# $PS1 — Prompt Statement - define the view of prompt statement
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" - install OH MY ZSH with colored PS
git log -p --oneline myfile	# help to find changes in myFile through commits
git log --name-status myFile# help to find changes in myFile through commits

				hexlet.git.13	Understanding git
git log --graph				# show graph of commits
git switch -c myBranch		# --create - create new branch myBranch and switch into
git switch myBranch			# switch to branch myBranch
git push origin myBranch	# push to branch myBranch
https://learngitbranching.js.org/?locale=ru_RU		# Game about branches
https://trunkbaseddevelopment.com/					# Trunk Based Development

				hexlet.git.14	Gitignore
.gitignore					# in hive directory - contains list of all files ignored by git
	myFile or myDirectory	# ignore myFile or myDirectory in every directory
	/myFile or /myDirectory # ignore myFile or myDirectory in specified directory
	/db/*.sqlite3			# ignore all *.sqlite3 in /db
	doc/**/*.txt			# ignore all *.txt in /doc and all inner directories
git rm myFile --cached		# remove myFile from repositore, but not from working directory
BIG Gitignore collection	# https://github.com/github/gitignore

				hexlet.git.15	Stash
git stash					# stash all tracked and indexed files
git stash -u				# --include-untracked	- also stash untracked files
git stash -a				# --all					- also stash ignored files
git stash --patch			# ask to stash for each change
git stash --list			# show all stashes
git stash apply				# restore last stash to WD
git stash apply stash@{2}	# restore stash@{2} to WD
git stash apply --index		# restore last stash to WD and to index (do not deletes stash)
git stash drop stash@{0}	# delete stash
git stash pop				# restore stash and drop it then
git stash --keep-index		# stash WD and index, not clean index

				hexlet.git.16	OSS - Open source software
nothing to note

				LearnGitBranching
git branch						# show all branches on local repository
git branch -a					# show all branches on remote repository
git branch    <what>			# make new branch <what> on HEAD
git branch    <what> <where>	# make new branch <what> on <where>
git branch -f <what> <where>	# move <what> branch pointer to <there>
git branch -d <what>			# delete <what> branch (can`t delete current branch)
git branch -m <what>			# rename current branch to <what>
git branch -vv					# show binding of current branch to remote branch

git checkout    <what>			# move HEAD to check out <what>
git checkout -b <what>			# move HEAD to check out (make <what>branch on HEAD)
git checkout -b <what> <where>	# move HEAD to check out (make <what>branch on <where>)

git merge <what>				# merge <what> branch to HEAD (make new merging commit)
git merge -m 'Comnt' <what>		# use -m 'Comment' like to every other commit

git rebase    <where>			# rebase current branch to <where> (make copys of all commits)
git rebase    <where> <what>	# rebase  <what>branch  to <where> and checkout <what>
git rebase -i <where>		# interactive rebase HEAD into new custom copy of released commits with pick/omit
	 						# flags (pick - onbord released commits, omit - pass released commit)
							# also interactive rebase helps change commit order in new commit-way

git cat-file -t <object>	# show <object> type (blob, tree, commit, tag)
git cat-file -p <object>	# show <object> deteling

		RELATIVE REFS				G   H   I   J		A =      = A^0
git log --graph						 \ /     \ /		B = A^   = A^1     = A~1		
	# displays history				  D   E   F			C = A^2
	# in the opposite order			   \  |  / \		D = A^^  = A^1^1   = A~2
										\ | /   |		E = B^2  = A^^2
	# ~ - tilde							 \|/    |		F = B^3  = A^^3
	# ^ - caret							  B     C		G = A^^^ = A^1^1^1 = A~3
										   \   /		H = D^2  = B^^2    = A^^^2  = A~2^2
											\ /			I = F^   = B^3^    = A^^3^
											 A			J = F^2  = B^3^2   = A^^3^2

git cherry-pick <what1> <what2> ...		# copy specified commits to HEAD
git tag <what> <where>		# make tag <what> to <where> commit
							# tag - constant pointer to spesify commit
git describe <what>			# describe <what>commit by nearest tag:	<tag>_<numCommits>_g<hash>


				REMOTE REPO
origin					# common local pointer to remote repo
origin/<branch>			# common local pointer to <branch> in origin repo
						# origin/<branch> accepts hash only from origin repo
git fetch				# get all remote repo changes to local one
git pull				# = git fetch + git merge origin/<branch>	# Merge origin/<branch> to local <branch>
git pull --rebase		# = git fetch + git rebase origin/<branch> 	# Rebase local <branch> to origin/<branch>
git push				# push current local branch to origin
						# (work only on matching root of <branch> and origin/<branch>)
						# git pull   and   git pull --rebase   used to match <branch> and origin/<branch>

git checkout -b <branch> o/main		# make        <branch> following by o/main
git  branch  -u o/main <branch>		# make        <branch> following by o/main
git  branch  -u o/main				# make current<branch> following by o/main

git push origin <branch>			# push local <branch>       to origin/<branch>	(HEAD-position independent)
git push origin <source>:<recipient># push local <source>branch to origin/<recipient>branch		(refspec)
									# <source> - branch or relative ref or hash
									# create <recipient>branch in case of absence

git fetch origin <branch>				# fetch origin/<branch> to local <branch>
git fetch origin <source>:<recipient>	# fetch origin/<source> to local <recipient>branch
										# create <recipient>branch on HEAD in case of absence

git push origin  :<recipient>		# remove <recipient>pointer in origin
git fetch origin :<recipient>		# create <recipient>branch on HEAD in case of absence only

git pull origin main				# merge new commits from o/main to local current branch throught local main
git pull origin main:foo			# merge new commits from o/main to local current branch throught new foo
